# 02

## react hook
* react(18.3.1/19-beta)内置的hook有下面17个
* 严格模式dev环境hook操作会连续执行2次来排查错误
* 规则
    * use开头
    * 写在顶层(不能在循环,if,事件处理等等里面)
    * 只在函数组件和自定义hook里使用hook(不在普通函数使用)

### 状态
* useState(让函数组件拥有状态)
    * 参数是状态的初始值
        * 参数可以是无参函数, 返回值作为初始值
            * 注意不要直接调用函数
        * 初始化值只生效一次, 可以用于记录第一次传入的props(后续变更无法察觉)
    * 返回状态当前值和更改状态方法(setState)的数组, 常用解构取值
    * setState可以直接写新状态, 也可以写函数接受当前状态返回新状态
        * 更新状态是放入队列然后异步更新, 直接取拿不到最新值, 可以在setState的函数参数的参数里拿到
            * 尽可能不用flushSync
        * 新旧状态一致(Object.is)时不会重新渲染 ~~比较引用,所以push数组再返回原数组无效~~
    * 渲染阶段(顶层代码)只能 ***有条件的*** 调用当前组件setState, 不能调用其他组件setState ~~避免死循环,避免产生副作用~~
    * 定义时候规范
        * 尽可能少的状态数量 ~~相关的状态合并成一个, 能从其他状态计算得出(拼接,筛选)就不要单独定义, 防止改漏了~~
        * 尽可能浅的状态结构 ~~过深将导致更新state要写很多的...,扁平化~~
* useReducer(状态管理的聚合)
    * 参数
        * 参数1: 是一个方法, 方法参数是(当前)state和action, 根据action来更新state并返回更新后的state
        * 参数2: 初始值, 或者计算初始值的方法
        * 参数3: 可选参数, 有值则作为参数2方法的参数计算初始值
    * 返回当前状态和更新状态的方法(dispatch)的数组, 常用解构取值
        * dispatch用于触发参数1的方法, 传入action
    * 特性和setState一致, 注意不要写异步请求 ~~渲染时执行,需要是纯函数~~
    * 针对于state的改修逻辑很多时才建议使用reducer, 逻辑分离单独调试会更方便
    * [use-immer库](https://github.com/immerjs/use-immer): 对useState的包装, 封装了对象的变更操作 ~~屏蔽了数据不可变性,容易带坏小朋友~~
* useOptimistic(乐观更新UI)
    * 乐观就是先把ui给更新了, 但是异步操作没结束(db还没插进去)呢, 等异步结束之后再更新ui
        * 乐观更新适用于成功率极高, 可以撤回的场合 ~~抢票就不行,先提示成功,再出失败就气死了~~
    * 参数
        * 参数1: 初始值
        * 参数2: 是一个方法, 方法参数是(当前)state和待更新的值, 返回乐观state(临时副本)
            * 注意是临时副本, 原state并未变化, 所以是可撤回的, 同时异步操作正确结束时也可以更新正确的值
    * 返回临时副本和更新状态的方法(addOptimistic)
        * addOptimistic的参数就是参数2的待更新的值
